/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export declare namespace IBestDexLens {
  export type SharesStruct = {
    firstAssetShares: BigNumberish;
    depositInThirdAssetShares: BigNumberish;
    depositToBorrowedShares: BigNumberish;
  };

  export type SharesStructOutput = [
    firstAssetShares: bigint,
    depositInThirdAssetShares: bigint,
    depositToBorrowedShares: bigint
  ] & {
    firstAssetShares: bigint;
    depositInThirdAssetShares: bigint;
    depositToBorrowedShares: bigint;
  };

  export type DexWithAncillaryDataStruct = {
    dex: string;
    ancillaryData: BytesLike;
  };

  export type DexWithAncillaryDataStructOutput = [
    dex: string,
    ancillaryData: string
  ] & { dex: string; ancillaryData: string };

  export type BestDexByOrderParamsStruct = {
    positionManager: AddressLike;
    limitOrderManager: AddressLike;
    orderId: BigNumberish;
    shares: IBestDexLens.SharesStruct;
    dexes: IBestDexLens.DexWithAncillaryDataStruct[];
    depositBorrowedAssetOracleData: BytesLike;
    pullOracleData: BytesLike[][];
    pullOracleTypes: BigNumberish[];
  };

  export type BestDexByOrderParamsStructOutput = [
    positionManager: string,
    limitOrderManager: string,
    orderId: bigint,
    shares: IBestDexLens.SharesStructOutput,
    dexes: IBestDexLens.DexWithAncillaryDataStructOutput[],
    depositBorrowedAssetOracleData: string,
    pullOracleData: string[][],
    pullOracleTypes: bigint[]
  ] & {
    positionManager: string;
    limitOrderManager: string;
    orderId: bigint;
    shares: IBestDexLens.SharesStructOutput;
    dexes: IBestDexLens.DexWithAncillaryDataStructOutput[];
    depositBorrowedAssetOracleData: string;
    pullOracleData: string[][];
    pullOracleTypes: bigint[];
  };

  export type GetBestMultipleDexesReturnParamsStruct = {
    returnAmount: BigNumberish;
    estimateGasAmount: BigNumberish;
    megaRoutes: PrimexPricingLibrary.MegaRouteStruct[];
  };

  export type GetBestMultipleDexesReturnParamsStructOutput = [
    returnAmount: bigint,
    estimateGasAmount: bigint,
    megaRoutes: PrimexPricingLibrary.MegaRouteStructOutput[]
  ] & {
    returnAmount: bigint;
    estimateGasAmount: bigint;
    megaRoutes: PrimexPricingLibrary.MegaRouteStructOutput[];
  };

  export type GetBestDexByOrderReturnParamsStruct = {
    firstAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStruct;
    depositInThirdAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStruct;
    depositToBorrowedReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStruct;
  };

  export type GetBestDexByOrderReturnParamsStructOutput = [
    firstAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput,
    depositInThirdAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput,
    depositToBorrowedReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput
  ] & {
    firstAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
    depositInThirdAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
    depositToBorrowedReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
  };

  export type BestDexForOpenablePositionParamsStruct = {
    positionManager: AddressLike;
    borrowedAsset: AddressLike;
    borrowedAmount: BigNumberish;
    depositAsset: AddressLike;
    depositAmount: BigNumberish;
    positionAsset: AddressLike;
    shares: IBestDexLens.SharesStruct;
    dexes: IBestDexLens.DexWithAncillaryDataStruct[];
  };

  export type BestDexForOpenablePositionParamsStructOutput = [
    positionManager: string,
    borrowedAsset: string,
    borrowedAmount: bigint,
    depositAsset: string,
    depositAmount: bigint,
    positionAsset: string,
    shares: IBestDexLens.SharesStructOutput,
    dexes: IBestDexLens.DexWithAncillaryDataStructOutput[]
  ] & {
    positionManager: string;
    borrowedAsset: string;
    borrowedAmount: bigint;
    depositAsset: string;
    depositAmount: bigint;
    positionAsset: string;
    shares: IBestDexLens.SharesStructOutput;
    dexes: IBestDexLens.DexWithAncillaryDataStructOutput[];
  };

  export type GetBestMultipleDexesParamsStruct = {
    positionManager: AddressLike;
    assetToBuy: AddressLike;
    assetToSell: AddressLike;
    amount: BigNumberish;
    isAmountToBuy: boolean;
    shares: BigNumberish;
    gasPriceInCheckedAsset: BigNumberish;
    dexes: IBestDexLens.DexWithAncillaryDataStruct[];
  };

  export type GetBestMultipleDexesParamsStructOutput = [
    positionManager: string,
    assetToBuy: string,
    assetToSell: string,
    amount: bigint,
    isAmountToBuy: boolean,
    shares: bigint,
    gasPriceInCheckedAsset: bigint,
    dexes: IBestDexLens.DexWithAncillaryDataStructOutput[]
  ] & {
    positionManager: string;
    assetToBuy: string;
    assetToSell: string;
    amount: bigint;
    isAmountToBuy: boolean;
    shares: bigint;
    gasPriceInCheckedAsset: bigint;
    dexes: IBestDexLens.DexWithAncillaryDataStructOutput[];
  };
}

export declare namespace PrimexPricingLibrary {
  export type PathStruct = {
    dexName: string;
    shares: BigNumberish;
    payload: BytesLike;
  };

  export type PathStructOutput = [
    dexName: string,
    shares: bigint,
    payload: string
  ] & { dexName: string; shares: bigint; payload: string };

  export type RouteStruct = {
    to: AddressLike;
    paths: PrimexPricingLibrary.PathStruct[];
  };

  export type RouteStructOutput = [
    to: string,
    paths: PrimexPricingLibrary.PathStructOutput[]
  ] & { to: string; paths: PrimexPricingLibrary.PathStructOutput[] };

  export type MegaRouteStruct = {
    shares: BigNumberish;
    routes: PrimexPricingLibrary.RouteStruct[];
  };

  export type MegaRouteStructOutput = [
    shares: bigint,
    routes: PrimexPricingLibrary.RouteStructOutput[]
  ] & { shares: bigint; routes: PrimexPricingLibrary.RouteStructOutput[] };
}

export interface IBestDexLensInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "getBestDexByOrder"
      | "getBestDexByPosition"
      | "getBestDexForOpenablePosition"
      | "getBestMultipleDexes"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getBestDexByOrder",
    values: [IBestDexLens.BestDexByOrderParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getBestDexByPosition",
    values: [
      AddressLike,
      BigNumberish,
      BigNumberish,
      IBestDexLens.DexWithAncillaryDataStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getBestDexForOpenablePosition",
    values: [IBestDexLens.BestDexForOpenablePositionParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getBestMultipleDexes",
    values: [IBestDexLens.GetBestMultipleDexesParamsStruct]
  ): string;

  decodeFunctionResult(
    functionFragment: "getBestDexByOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBestDexByPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBestDexForOpenablePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBestMultipleDexes",
    data: BytesLike
  ): Result;
}

export interface IBestDexLens extends BaseContract {
  connect(runner?: ContractRunner | null): IBestDexLens;
  waitForDeployment(): Promise<this>;

  interface: IBestDexLensInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getBestDexByOrder: TypedContractMethod<
    [_params: IBestDexLens.BestDexByOrderParamsStruct],
    [IBestDexLens.GetBestDexByOrderReturnParamsStructOutput],
    "payable"
  >;

  getBestDexByPosition: TypedContractMethod<
    [
      _positionManager: AddressLike,
      _positionId: BigNumberish,
      _shares: BigNumberish,
      _dexesWithAncillaryData: IBestDexLens.DexWithAncillaryDataStruct[]
    ],
    [IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput],
    "nonpayable"
  >;

  getBestDexForOpenablePosition: TypedContractMethod<
    [_params: IBestDexLens.BestDexForOpenablePositionParamsStruct],
    [
      [
        IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput,
        IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput,
        IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput
      ] & {
        _firstAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
        _depositInThirdAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
        _depositToBorrowedReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
      }
    ],
    "nonpayable"
  >;

  getBestMultipleDexes: TypedContractMethod<
    [_params: IBestDexLens.GetBestMultipleDexesParamsStruct],
    [IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "getBestDexByOrder"
  ): TypedContractMethod<
    [_params: IBestDexLens.BestDexByOrderParamsStruct],
    [IBestDexLens.GetBestDexByOrderReturnParamsStructOutput],
    "payable"
  >;
  getFunction(
    nameOrSignature: "getBestDexByPosition"
  ): TypedContractMethod<
    [
      _positionManager: AddressLike,
      _positionId: BigNumberish,
      _shares: BigNumberish,
      _dexesWithAncillaryData: IBestDexLens.DexWithAncillaryDataStruct[]
    ],
    [IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getBestDexForOpenablePosition"
  ): TypedContractMethod<
    [_params: IBestDexLens.BestDexForOpenablePositionParamsStruct],
    [
      [
        IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput,
        IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput,
        IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput
      ] & {
        _firstAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
        _depositInThirdAssetReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
        _depositToBorrowedReturnParams: IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getBestMultipleDexes"
  ): TypedContractMethod<
    [_params: IBestDexLens.GetBestMultipleDexesParamsStruct],
    [IBestDexLens.GetBestMultipleDexesReturnParamsStructOutput],
    "nonpayable"
  >;

  filters: {};
}
